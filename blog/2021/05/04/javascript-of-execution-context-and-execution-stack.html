<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="viewport"
          content="width=device-width, user-scalable=yes, initial-scale=1.0, maximum-scale=3.0, minimum-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <title>JavaScript系列之执行上下文和执行栈</title>
    <meta name="description" content="A front-end engineer's article sharing"/>
    <meta name="keywords" content="blog,javascript,typescript,passionate,self-taught,career-changed,front-end developer"/>

    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Alegreya:400,400i|Lato:400,400i,700,900|Roboto+Mono:400,300">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"/>
    <link rel="stylesheet" href="/css/normalize.css"/>
    <link rel="stylesheet" href="/css/theme.css"/>
    <link rel="stylesheet" href="/css/markdown.css"/>
    <link rel="stylesheet" href="/css/prose.css"/>
</head>
<body>
<nav class="nav prose">
    <div class="nav__left">
        <a href="/">Home</a>
        <a href="/about">About</a>
    </div>
    <div class="nav__right">
        
            <a target="_blank" href="https://github.com/zonemeen" class="link-github">Github</a>
        
            <a target="_blank" href="https://twitter.com/zonemeen" class="link-github">Twitter</a>
        
    </div>
</nav>

<article class="mar-b-7 prose">
    <header class="text-center">
        <h1 class="mar-b-7">JavaScript系列之执行上下文和执行栈</h1>
        <time class="mar-b-6" datetime="Tue, May 04, 2021">Tue, May 04, 2021</time>
    </header>
    <p><div class="table-of-contents"><ul><li><a href="#执行上下文（execution-context）">执行上下文（Execution Context） </a></li><li><a href="#执行上下文栈（execution-context-stack）">执行上下文栈（Execution Context Stack） </a></li><li><a href="#执行上下文是如何执行的呢？">执行上下文是如何执行的呢？ </a></li><li><a href="#不同执行上下文中的变量是不同的">不同执行上下文中的变量是不同的 </a></li><li><a href="#注意">注意 </a></li></ul></div></p>
<p>如果你想成为一名优秀的 JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。</p>
<p>执行上下文和执行栈是 JavaScript 的难点之一，所以本人尽量用通俗易懂的方式来阐述这些概念。</p>
<h3 id="执行上下文（execution-context）" tabindex="-1">执行上下文（Execution Context） <a class="header-anchor" href="#执行上下文（execution-context）" aria-hidden="true">#</a></h3>
<p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。执行上下文（可执行代码段）总共有三种类型：</p>
<ul>
<li><strong>全局执行上下文（全局代码）</strong>：不在任何函数中的代码都位于全局执行上下文中，只有一个，浏览器中的全局对象就是 <code>window</code> 对象，<code>this</code> 指向这个全局对象。</li>
<li><strong>函数执行上下文（函数体）</strong>：只有调用函数时，才会为该函数创建一个新的执行上下文，可以存在无数个，每当一个新的执行上下文被创-建，它都会按照特定的顺序执行一系列步骤。</li>
<li><strong><code>Eval</code> 函数执行上下文（eval 代码）</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</li>
</ul>
<p>执行上下文又包括三个生命周期阶段：<strong>创建阶段 → 执行阶段 → 回收阶段</strong>，本文重点介绍创建阶段。</p>
<p><strong>1.创建阶段</strong></p>
<p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p>
<ul>
<li><strong>创建变量对象(Variable object，VO)</strong>：首先初始化函数的参数<code>arguments</code>，提升函数声明和变量声明。后文会详细说明。</li>
<li><strong>创建作用域链（Scope Chain</strong>：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。后文会详细说明。</li>
<li><strong>确定 this 指向</strong>：包括多种情况，后文会详细说明。</li>
</ul>
<p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为<code>undefined</code>，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p>
<p>另外，一个函数在被执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上下文中会多出<code>this</code> 、 <code>arguments</code>和函数的参数。</p>
<p><strong>2.执行阶段</strong></p>
<p>进入执行上下文、执行代码</p>
<p><strong>3.回收阶段</strong></p>
<p>执行完毕后执行上下文出栈并等待被垃圾回收</p>
<p><img src="/assets/scopechain/1.jpg" alt="" /></p>
<h3 id="执行上下文栈（execution-context-stack）" tabindex="-1">执行上下文栈（Execution Context Stack） <a class="header-anchor" href="#执行上下文栈（execution-context-stack）" aria-hidden="true">#</a></h3>
<p>假如我们写的函数多了，每次调用函数时都创建一个新的执行上下文，如何管理创建的那么多执行上下文呢？</p>
<p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，具有 LIFO（后进先出）的栈结构，用于存储在代码执行期间创建的所有执行上下文。</p>
<p>首次运行 JS 代码时，会创建一个<strong>全局</strong>执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个<strong>新的函数</strong>执行上下文并 Push 到当前执行栈的顶部，浏览器的 JS 执行引擎总是访问栈顶的执行上下文。</p>
<p>根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的<strong>函数</strong>执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执行栈的<strong>下一个</strong>执行上下文，最终移回到<strong>全局</strong>执行上下文，全局上下文只有唯一的一个，它在浏览器关闭时 Pop 出。</p>
<p>看到目前为止，是否觉得这两个概念还是有点晦涩难懂呢？那…接下来通过几小段代码和图解来详细介绍并理解吧。</p>
<h3 id="执行上下文是如何执行的呢？" tabindex="-1">执行上下文是如何执行的呢？ <a class="header-anchor" href="#执行上下文是如何执行的呢？" aria-hidden="true">#</a></h3>
<p>让我们先来看一下这段简单代码：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>这段代码背后执行的逻辑是这样的：</p>
<p>首先，全局执行上下文（Global Execution Context）会被建立，这时候会一并建立<code>this</code>、<code>global object</code> (<code>window</code>)，在函数开始执行的过程中，<code>function a</code>和<code>b</code>由于 JS 提升机制的缘故会先被建立在内存中，接着才会开始逐行执行函数。</p>
<p><img src="/assets/context/1.jpg" alt="" /></p>
<p>接着，代码会执行到<code>a( )</code>这个部分，这时候，会建立<code>a</code>的执行上下文（execution context），并且被放置到执行栈（execution stack）中。在这个 execution stack 中，最上面的 execution context 会是正在被执行的<code>a( )</code>。如下图：</p>
<p><img src="/assets/context/2.jpg" alt="" /></p>
<p><code>function a</code> 的 execution context 建立后，便会开始执行<code>function a</code>中的内容。由于在<code>function a( )</code> 里面有去执行<code>function b</code> ，因此，在这个 execution stack 中，接下来最上面会变成<code>function b</code> 的 execution context。如下图：</p>
<p><img src="/assets/context/3.jpg" alt="" /></p>
<p>当<code>function b</code> 执行完之后，会从 execution stack 中离开，继续逐行执行<code>function a</code>。当<code>function a</code> 执行完之后，一样会从 execution stack 中抽离，再回到 Global Execution Context 逐行执行。如下图：</p>
<p><img src="/assets/context/4.jpg" alt="" /></p>
<h3 id="不同执行上下文中的变量是不同的" tabindex="-1">不同执行上下文中的变量是不同的 <a class="header-anchor" href="#不同执行上下文中的变量是不同的" aria-hidden="true">#</a></h3>
<p>在了解了一般的函数其运作背后的逻辑后，让我们来看一下这段代码：</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> myVar<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> myVar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> myVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>你可以想像，如果我们在不同的 execution context 中去把<code>myVar</code>这个变量打出来，会得到什么结果呢？结果如下：</p>
<p><img src="/assets/context/5.jpg" alt="" /></p>
<p>我们分别得到了 1、<code>undefined</code>和 2。为什么会这样呢？</p>
<p>让我们来看看这段代码背后执行的逻辑：</p>
<p>首先，全局执行上下文（Global Execution Context）会被建立，由于变量提升的缘故，<code>myVar</code>、<code>function a</code>和<code>b</code>都会被建立并储存在内存中，接着便开始逐行执行函数。一开始会碰到<code>var myVar = 1</code>所以，最外层的<code>myVar</code>便被给值为 1，接着执行到了<code>console.log(myVar)</code>，这是在 global execution context 执行的，于是得到了第一个 1 的结果：</p>
<p><img src="/assets/context/6.jpg" alt="" /></p>
<p>然后执行到了<code>a ( )</code>，于是建立了<code>a</code>的 execution context，这时候由于逐行执行的关系，会先执行到<code>var myVar = 2</code>，但因为这是在 function a 的 execution context 中，所以并不会影响到 global execution context 的<code>myVar</code>：</p>
<p><img src="/assets/context/7.jpg" alt="" /></p>
<p>在执行完<code>function a</code>中的<code>var myVar = 2</code>后，继续逐行执行，于是执行到了<code>b ( )</code>，这时候，<code>function b</code>的 execution function 便被建立，而且会先去执行<code>function b</code>里面的内容：</p>
<p><img src="/assets/context/8.jpg" alt="" /></p>
<p><code>function b</code>的 execution function 建立后，会开始逐行执行<code>function b</code>里面的内容，于是读到了<code>var myVar</code>;，这时候在<code>function b</code>这个 execution context 中的<code>myVar</code>变量被建立，但是还没被赋值，所以会是<code>undefined</code>。和上面提到的一样，由于这个<code>myVar</code>是在<code>function b</code>中的 execution context 所建立，所以并不会影响到其他 execution context 的<code>myVar</code>，这时候执行到了<code>function b</code>的 execution context 中的<code>console.log(myVar)</code>，于是得到了第二个看到的<code>undefined</code>：</p>
<p><img src="/assets/context/9.jpg" alt="" /></p>
<p>最后，<code>function b</code>执行完之后，会从 execution stack 中离开，继续回到<code>function a</code>中的<code>b( )</code>后逐行执行，也就是<code>console.log(myVar)</code>，这时候是在 function a 的 execution context 加以执行的，因此也就得到了结果中看到的第三个 2 了。</p>
<p>最后由于<code>b ( )</code> 后面已经没有内容，<code>function a</code>执行完毕，这时候，<code>function a</code>也会从 execution stack 中抽离。</p>
<p><img src="/assets/context/10.jpg" alt="" /></p>
<p>最后回到 Global Execution Context，如果函数中的<code>a( )</code>后面还有内容的话，会继续进行逐行执行。</p>
<p>由上面的例子，我们可以知道，我们是在不同的 execution context 中分别去声明变量<code>myVar</code>的，<strong>因此在不同的 execution context，变量彼此之间不会影响</strong>，所以虽然这三个变量都叫做<code>myVar</code>，但其实是三个不同的变量。</p>
<p>由于我们是在不同的 execution context 中去声明变量，所以这其实是位于三个不同 execution context 中的变量，所以即使我们是在执行完<code>a( )</code>后再去调用一次<code>myVar</code>，一样会得到&quot; 1&quot;的结果:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> myVar<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> myVar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> myVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 一样会得到"1"</span>
</code></pre>
<h3 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-hidden="true">#</a></h3>
<p>最后需要注意的是，如果是在<code>function</code>里面直接使用<code>myVar</code>这个变量，而没有通过<code>var</code>重新声明它的话，就会得到不同的结果！因为在函数作用域内加 <code>var</code> 定义的变量是局部变量，不加 <code>var</code> 定义的就成了全局变量。在未声明新的变量的情况下，在该 execution context 中 JavaScript 引擎找不到这个变量，它就会往它的外层去寻找，最后会得到，1 ,2 ,2 ,2 的结果:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  myVar<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  myVar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> myVar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myVar<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
打印出
1
2
2
2
*/</span>
</code></pre>
<p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io" target="_blank" rel="noopener">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>

</article>

<footer class="text-center mar-tb-6 prose">
    © 2022 zonemeen, unless otherwise stated.
</footer>

<script>hljs.highlightAll();</script>
</body>
</html>
